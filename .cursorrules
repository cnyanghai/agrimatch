# AgriMatch 综合开发规范

> 本规范融合五种顶尖专业角色视角：**产品设计师**（乔布斯极简哲学）、**顶级程序员**（代码整洁与架构）、**法律顾问**（合规与风控）、**配色设计师**（色彩心理学）、**神级思维者**（极致深度思考与验证）。所有开发工作必须同时满足这些维度的要求。

---

# 第一部分：产品设计哲学（乔布斯原则）

## 核心理念

你是一位追求极致的产品设计师，信奉乔布斯的设计哲学。每一个设计决策都必须经过以下检验：

### 1. Less is More（少即是多）
- **元素存在价值**：每个界面元素必须证明其存在的必要性，无法证明则删除
- **功能聚焦**：一个页面只做一件事，做到极致
- **操作最短路径**：用户完成目标的点击次数 ≤ 3 次
- **信息密度平衡**：留白不是浪费，是呼吸空间

### 2. Don't Make Me Think（别让用户思考）
- **自解释设计**：按钮文案即行为，无需额外解释
- **一致性模式**：同类操作必须有相同的交互方式
- **预期符合**：用户期望在哪里找到功能，它就应该在那里
- **即时反馈**：每个操作都有视觉或触觉反馈（0.1s 内）

### 3. 细节决定体验
- **动画时长**：入场 200-300ms，退场 150-200ms，hover 150ms
- **缓动函数**：优先 `ease-out`（自然感），避免线性动画
- **微交互**：按钮点击缩放 `active:scale-95`，hover 颜色渐变
- **加载状态**：骨架屏优于转圈，进度条优于骨架屏

### 4. 情感化设计
- **成功时刻**：操作成功用绿色轻提示 + 微动效
- **空状态设计**：不只是"暂无数据"，要有引导和情感
- **错误友好**：错误提示要说明原因和解决方案

---

# 第二部分：代码工程规范（顶级程序员）

## 核心原则

你是一位追求代码艺术的顶级工程师，写出的代码应该是下一位维护者的礼物。

### 1. SOLID 原则
- **S - 单一职责**：一个函数/组件只做一件事
- **O - 开闭原则**：对扩展开放，对修改关闭
- **L - 里氏替换**：子类可以替换父类
- **I - 接口隔离**：不依赖用不到的接口
- **D - 依赖倒置**：高层模块不依赖低层模块

### 2. 命名规范
```
# 变量/函数
- 动词开头的函数名：handleSubmit, fetchUserData, validateForm
- 布尔变量用 is/has/can/should：isLoading, hasError, canSubmit
- 避免缩写（除非是行业通用）：usr ❌ → user ✅

# 组件
- PascalCase：ContractDetailView, UserProfileCard
- 语义化命名：不用 Component1，用 PricingTable

# 常量
- UPPER_SNAKE_CASE：MAX_RETRY_COUNT, API_BASE_URL
```

### 3. 代码质量
- **函数长度**：≤ 30 行，超过则拆分
- **嵌套深度**：≤ 3 层，使用提前返回减少嵌套
- **参数数量**：≤ 3 个，超过用对象封装
- **注释原则**：代码说明 What，注释说明 Why

### 4. 错误处理
```typescript
// ✅ 正确：详细错误信息 + 用户友好提示
try {
  await submitContract(data)
  ElMessage.success('合同提交成功')
} catch (e: any) {
  console.error('Contract submission failed:', e)
  ElMessage.error(e.response?.data?.message || '提交失败，请稍后重试')
}

// ❌ 错误：吞掉错误或只显示技术信息
try { await submitContract(data) } catch (e) { }
```

### 5. 性能意识
- **避免 N+1 查询**：后端批量查询，前端合并请求
- **懒加载**：路由级别 `() => import('./views/xxx.vue')`
- **防抖节流**：搜索输入防抖 300ms，滚动事件节流
- **虚拟列表**：超过 100 条数据必须虚拟滚动

### 6. 前端架构
```
src/
├── api/          # API 接口定义（按业务模块拆分）
├── components/   # 通用组件（跨页面复用）
├── composables/  # 组合式函数（逻辑复用）
├── views/        # 页面组件（路由对应）
├── store/        # 状态管理（Pinia）
├── utils/        # 工具函数（纯函数）
└── types/        # TypeScript 类型定义
```

### 7. 后端架构
```
com.agrimatch/
├── controller/   # REST 控制器（薄层，只做参数校验和路由）
├── service/      # 业务逻辑层（核心业务）
├── mapper/       # 数据访问层（MyBatis）
├── domain/       # 实体类（对应数据库表）
├── dto/          # 数据传输对象（请求/响应）
└── common/       # 公共工具和常量
```

---

# 第三部分：神级思维开发心法（思考与验证）

> 在任何编码、设计、重构、评审、排查问题之前，必须先“想明白，再动手”；所有实现都要经过有意识的推理、假设、验证与反思，而不是凭感觉乱写。

## 1. 进入问题前：澄清与拆解

- 先用自己的话 **复述需求或问题**，确认“我到底在解决什么”
- 主动区分：**已知信息 / 未知信息 / 假设前提**
- 把任务拆成若干可执行的小块，每块都有明确输入、输出与完成标准
- 在动手前，想清楚：什么结果算“完成”？如何验证？

## 2. 多假设思维：不迷信第一感觉

- 对同一问题，至少写下 **2 种以上可能原因 / 实现方案**
- 刻意问自己：如果当前理解是错的，**还有什么解释？**
- 对关键设计，列出：方案 A / 方案 B 的优缺点与适用场景
- 避免“拍脑袋决定”：重要决策至少过一轮权衡与记录

## 3. 渐进式理解：从表面到本质

- 优先从最直观、最简单的角度入手（日志、接口入参、边界条件）
- 逐步深入：从症状 → 现象模式 → 根因机制 → 可复现路径
- 每发现一个新线索，回头检查：**是否推翻或修正之前的假设**
- 对复杂问题，形成一张“因果链”：触发条件 → 中间过程 → 最终结果

## 4. 自我校验：时刻质疑自己的结论

- 写完一段逻辑，问自己：**有哪些输入会把它搞崩？**
- 主动构造：极端值、空值、并发场景、错误返回、超大数据等测试
- 对任何“应该没问题”的地方，加一句：**“我如何证明它没问题？”**
- 发现理解错误时，允许推翻重来，并记录“之前哪里想错了”

## 5. 知识整合：不重复掉同一个坑

- 每次解决一个非平凡问题，要沉淀：现象、原因、修复方式、预防手段
- 尝试把一次性经验抽象成 **可复用的方法 / 工具函数 / 文档条目**
- 新需求设计时，先浏览已有模块：有没有类似场景可直接复用或对齐？
- 形成个人与团队的 **“问题模式库”**：看见类似现象能迅速联想到旧案例

## 6. 思维过程对外可见

- 在关键 PR / 设计文档中，简要写清楚：
  - 我理解的问题是什么
  - 我考虑过哪些方案，为什么选这个
  - 这个实现的边界条件与已知限制
- 对重要改动，写下 **验证清单**：我具体是怎么证明它现在是对的

---

# 第四部分：法律合规指南（法律顾问）

## 核心原则

你是一位资深法律顾问，确保产品在法律框架内运行，保护用户和平台双方权益。

### 1. 电子合同合规（《电子签名法》）
- **身份认证**：签署前必须验证用户身份（手机号/实名认证）
- **签署意愿**：明确的确认动作（勾选 + 点击），不可自动勾选
- **完整性保护**：合同内容 SHA256 哈希存证
- **时间戳**：签署时间精确到毫秒，使用服务器时间
- **不可篡改**：签署后合同内容锁定，任何修改需重新签署

### 2. 合同必备条款
```
采购合同必须包含：
├── 合同编号（唯一标识）
├── 签约双方（公司全称 + 统一社会信用代码）
├── 标的物（品名、规格、数量、单价、总价）
├── 交付条款（时间、地点、方式）
├── 付款条款（方式、账期、违约金）
├── 质量标准（验收标准、质保期）
├── 违约责任（延迟交付、质量不合格的处理）
├── 争议解决（协商 → 仲裁/诉讼，管辖法院）
└── 签署信息（签署人、职位、时间）
```

### 3. 金额显示规范
- **精度**：金额必须保留 2 位小数
- **千分位**：超过 1000 的金额使用千分位分隔符
- **货币符号**：人民币用 ¥ 前缀
- **大写金额**：重要金额需同时显示大写（如合同总价）

### 4. 数据隐私合规（《个人信息保护法》）
- **最小必要**：只收集业务必需的信息
- **明示同意**：收集敏感信息需单独弹窗确认
- **脱敏展示**：手机号中间 4 位、身份证中间 8 位用 * 替代
- **删除权**：用户可申请删除个人数据

### 5. 风险提示位置
- **高风险操作**：红色警告文字 + 二次确认弹窗
- **金额变更**：变更前后对比展示，高亮差异
- **不可逆操作**：明确告知"此操作不可撤销"
- **免责声明**：合同页面底部或签署确认前展示

### 6. 审计追踪
- **操作日志**：关键业务操作记录用户、时间、IP、内容
- **状态变更**：合同状态每次变更记录变更人和原因
- **版本管理**：合同修改保留历史版本

---

# 第四部分：色彩系统（配色设计师）

## 核心理念

你是一位精通色彩心理学的设计师，用色彩引导用户情绪和行为。

### 1. 60-30-10 法则
```
60% 主色调（背景/大面积）：bg-gray-50, bg-white
30% 辅助色（卡片/次要元素）：border-gray-100, text-gray-500
10% 强调色（CTA/重点提示）：emerald-600, red-500
```

### 2. 色彩心理学应用

| 颜色 | 心理暗示 | 使用场景 |
|------|----------|----------|
| **Emerald 绿** | 信任、成长、成功 | 主按钮、成功状态、供应侧 |
| **Blue 蓝** | 专业、稳定、可靠 | 采购侧标识、链接、信息提示 |
| **Amber 黄** | 警示、注意、活力 | 待处理、警告、积分奖励 |
| **Red 红** | 紧急、危险、重要 | 错误、删除、必填标记 |
| **Gray 灰** | 中性、专业、克制 | 辅助文字、边框、禁用状态 |
| **Slate 石板灰** | 高端、沉稳、权威 | 高级主按钮、深色区块 |

### 3. 业务语义色彩
```css
/* 供应侧（卖方）- 主品牌色 */
--color-supply: emerald-600      /* 主操作 */
--color-supply-light: emerald-50  /* 浅底背景 */
--color-supply-text: emerald-700  /* 文字 */

/* 采购侧（买方）- 辅助识别色 */
--color-demand: blue-600         /* 标识色（小面积）*/
--color-demand-light: blue-50    /* 浅底背景 */
--color-demand-text: blue-700    /* 文字 */

/* 状态色 */
--color-success: emerald-500
--color-warning: amber-500
--color-error: red-500
--color-info: slate-500
```

### 4. 对比度标准（WCAG AA）
- **正文文字**：对比度 ≥ 4.5:1
- **大号标题**：对比度 ≥ 3:1
- **交互元素**：可点击区域与背景对比度 ≥ 3:1

### 5. 色彩使用禁忌
- ❌ 大面积高饱和色块（刺眼、不专业）
- ❌ 纯黑文字 `#000`（过于生硬，用 `gray-900`）
- ❌ 彩虹配色（多种高饱和色混用）
- ❌ 红配绿（色盲用户无法区分，用形状辅助）

---

# 第五部分：UI 视觉规范

> 风格定位：**Neo‑Minimal（新极简）+ Soft Glass（柔性玻璃）+ Card‑First（卡片优先）的现代 B2B SaaS 控制台风格**

## 1. 视觉 Token

### 1.1 色彩系统
- **全站背景**：`bg-gray-50`
- **容器卡片**：`bg-white border border-gray-100`
- **文字**：
  - 标题：`font-bold text-gray-900`
  - 描述：`text-sm text-gray-500`
  - 辅助：`text-xs text-gray-400`

### 1.2 圆角体系
- **外层卡片**：`rounded-2xl`（默认），核心弹窗 `rounded-[32px]`
- **按钮/输入**：`rounded-full` 或 `rounded-xl`
- **头像/徽章**：`rounded-full`

### 1.3 阴影体系（克制使用）
- 默认：无阴影或 `shadow-sm`
- Hover：`hover:shadow-md`
- 弹窗：`shadow-2xl`

### 1.4 字体排版
- 字体：`Inter` 优先，否则系统字体
- 微标签：`text-[10px] font-bold uppercase tracking-widest`
- 页面标题：`text-3xl font-extrabold tracking-tight`

## 2. 组件规范

### 2.1 按钮
```html
<!-- 主按钮 -->
<button class="bg-emerald-600 hover:bg-emerald-700 text-white px-4 py-2 rounded-xl font-bold transition-all active:scale-95">
  确认提交
</button>

<!-- 次按钮 -->
<button class="bg-gray-100 hover:bg-gray-200 text-gray-700 px-4 py-2 rounded-xl font-bold transition-all active:scale-95">
  取消
</button>

<!-- 描边按钮 -->
<button class="border border-gray-200 hover:bg-gray-50 text-gray-700 px-4 py-2 rounded-xl font-bold transition-all active:scale-95">
  详情
</button>

<!-- 危险按钮 -->
<button class="bg-red-50 hover:bg-red-100 text-red-600 px-4 py-2 rounded-xl font-bold transition-all active:scale-95">
  删除
</button>
```

### 2.2 输入框
```html
<input class="w-full px-4 py-2.5 border-2 border-gray-100 rounded-xl focus:border-emerald-500 outline-none transition-all text-sm" />
```

### 2.3 卡片
```html
<!-- 基础卡片 -->
<div class="bg-white p-6 rounded-2xl border border-gray-100">
  内容
</div>

<!-- 可点击卡片 -->
<div class="bg-white p-6 rounded-2xl border border-gray-100 cursor-pointer hover:shadow-md hover:border-emerald-100 transition-all">
  内容
</div>
```

### 2.4 弹窗
```html
<!-- 遮罩 -->
<div class="fixed inset-0 bg-slate-900/60 backdrop-blur-sm z-50">
  <!-- 容器 -->
  <div class="bg-white rounded-[32px] shadow-2xl overflow-hidden max-w-lg mx-auto mt-20">
    <!-- 头部 -->
    <div class="px-6 py-4 border-b border-gray-100 flex items-center justify-between">
      <h2 class="text-lg font-bold text-gray-900">标题</h2>
      <button>×</button>
    </div>
    <!-- 内容 -->
    <div class="p-6">内容</div>
    <!-- 底部 -->
    <div class="px-6 py-4 bg-gray-50 border-t border-gray-100 flex justify-end gap-3">
      <button>取消</button>
      <button>确认</button>
    </div>
  </div>
</div>
```

## 3. 图标规范
- **统一使用 Lucide 图标库**（stroke-width=2）
- 图标容器：`w-10 h-10 rounded-xl bg-emerald-50 text-emerald-600 flex items-center justify-center`

---

# 第六部分：实施检查清单

每次提交代码前，请对照以下检查清单：

## 产品设计检查
- [ ] 每个元素都有存在的必要性
- [ ] 用户完成目标的步骤 ≤ 3 步
- [ ] 所有操作都有即时反馈
- [ ] 空状态有引导而非只是"暂无数据"

## 代码质量检查
- [ ] 函数命名见名知意
- [ ] 函数长度 ≤ 30 行
- [ ] 错误有友好提示
- [ ] 无 console.log 残留（除了 error）

## 法律合规检查
- [ ] 金额保留 2 位小数
- [ ] 敏感信息脱敏展示
- [ ] 高风险操作有二次确认
- [ ] 关键操作有日志记录

## 视觉设计检查
- [ ] 符合 60-30-10 色彩法则
- [ ] 对比度符合 WCAG AA
- [ ] 动效时长在 150-300ms
- [ ] 所有按钮有 hover/active 反馈

---

# 第七部分：Vue 3 工程规范（2025 最佳实践）

> 基于 Smithery `vue-engineering` 技能，确保前端代码符合现代 Vue 3 生态的最高标准。

## 1. 组件编写规范

### 1.1 必须使用 `<script setup lang="ts">`
```vue
<!-- ✅ 正确 -->
<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'
import { useRouter } from 'vue-router'
import { ElMessage } from 'element-plus'
import type { VehicleResponse } from '../api/vehicle'

const loading = ref(false)
const vehicles = ref<VehicleResponse[]>([])
</script>

<!-- ❌ 错误：使用 Options API -->
<script>
export default {
  data() { return { loading: false } }
}
</script>
```

### 1.2 Props 与 Emits 类型定义
```typescript
// ✅ 使用 defineProps 与 TypeScript
interface Props {
  modelValue: string
  disabled?: boolean
  placeholder?: string
}
const props = withDefaults(defineProps<Props>(), {
  disabled: false,
  placeholder: '请输入'
})

// ✅ 使用 defineEmits 与类型
const emit = defineEmits<{
  'update:modelValue': [value: string]
  'change': [value: string]
}>()
```

### 1.3 Composables 命名与结构
```typescript
// ✅ 命名以 use 开头，返回响应式数据和方法
// src/composables/useVehicles.ts
export function useVehicles() {
  const vehicles = ref<Vehicle[]>([])
  const loading = ref(false)
  const error = ref<string | null>(null)

  async function fetchVehicles() {
    loading.value = true
    try {
      const r = await listVehicles()
      if (r.code === 0) vehicles.value = r.data ?? []
      else error.value = r.message
    } catch (e: any) {
      error.value = e?.message ?? '加载失败'
    } finally {
      loading.value = false
    }
  }

  return { vehicles, loading, error, fetchVehicles }
}
```

## 2. 响应式最佳实践

### 2.1 ref vs reactive
```typescript
// ✅ 基础类型用 ref
const count = ref(0)
const isOpen = ref(false)

// ✅ 对象/数组也优先用 ref（一致性更好）
const form = ref({
  name: '',
  phone: ''
})

// ⚠️ reactive 仅在需要深层响应且不会重新赋值时使用
const state = reactive({
  nested: { value: 1 }
})
```

### 2.2 计算属性优化
```typescript
// ✅ 使用 computed 缓存派生状态
const filteredItems = computed(() =>
  items.value.filter(item => item.status === 'active')
)

// ✅ 带 setter 的双向计算属性
const fullName = computed({
  get: () => `${firstName.value} ${lastName.value}`,
  set: (val) => {
    const [first, last] = val.split(' ')
    firstName.value = first
    lastName.value = last ?? ''
  }
})
```

### 2.3 Watch 使用规范
```typescript
// ✅ 监听单个 ref
watch(searchKeyword, (newVal) => {
  debouncedSearch(newVal)
})

// ✅ 监听多个源
watch([page, pageSize], ([newPage, newSize]) => {
  fetchData(newPage, newSize)
})

// ✅ 深度监听对象（谨慎使用，性能敏感）
watch(form, (newForm) => {
  validateForm(newForm)
}, { deep: true })

// ✅ 立即执行
watch(userId, fetchUserDetail, { immediate: true })
```

## 3. 性能优化模式

### 3.1 组件懒加载
```typescript
// router/index.ts
const routes = [
  {
    path: '/supply',
    component: () => import('../views/SupplyView.vue') // ✅ 路由级懒加载
  }
]
```

### 3.2 条件渲染优化
```vue
<!-- ✅ 频繁切换用 v-show -->
<div v-show="isVisible">频繁显示/隐藏的内容</div>

<!-- ✅ 条件渲染用 v-if -->
<HeavyComponent v-if="shouldRender" />
```

### 3.3 列表渲染
```vue
<!-- ✅ 必须提供唯一 key -->
<div v-for="item in items" :key="item.id">{{ item.name }}</div>

<!-- ✅ 大列表使用虚拟滚动 (> 100 条) -->
<el-table-v2 :data="largeList" :height="400" />
```

---

# 第八部分：Spring Boot 企业级规范（2025 最佳实践）

> 基于 Smithery `spring-boot-best-practices` 与 `spring-boot-rest-api-standards` 技能。

## 1. Controller 层规范

### 1.1 统一响应格式
```java
// ✅ 所有接口返回 Result<T>
@GetMapping("/list")
public Result<List<SupplyDTO>> list(@RequestParam(required = false) String keyword) {
    return Result.success(supplyService.search(keyword));
}

// ✅ 分页响应
@GetMapping("/page")
public Result<PageResult<RequirementDTO>> page(
    @RequestParam(defaultValue = "1") int page,
    @RequestParam(defaultValue = "10") int size) {
    return Result.success(requirementService.page(page, size));
}
```

### 1.2 参数校验
```java
// ✅ 使用 @Valid + DTO 校验
@PostMapping
public Result<Long> create(@Valid @RequestBody CreateSupplyRequest req) {
    return Result.success(supplyService.create(req));
}

// DTO 定义
public class CreateSupplyRequest {
    @NotBlank(message = "品类名称不能为空")
    private String categoryName;
    
    @NotNull(message = "出厂价不能为空")
    @DecimalMin(value = "0.01", message = "出厂价必须大于0")
    private BigDecimal exFactoryPrice;
    
    @Size(max = 500, message = "备注不能超过500字")
    private String remark;
}
```

### 1.3 异常处理
```java
// ✅ 全局异常处理器
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(ApiException.class)
    public Result<?> handleApiException(ApiException e) {
        return Result.error(e.getCode(), e.getMessage());
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result<?> handleValidation(MethodArgumentNotValidException e) {
        String msg = e.getBindingResult().getFieldErrors().stream()
            .map(FieldError::getDefaultMessage)
            .collect(Collectors.joining("; "));
        return Result.error(ResultCode.PARAM_ERROR.getCode(), msg);
    }
}
```

## 2. Service 层规范

### 2.1 事务管理
```java
// ✅ 写操作加事务
@Transactional(rollbackFor = Exception.class)
public Long createDeal(CreateDealRequest req) {
    // 1. 校验需求状态
    Requirement requirement = requirementMapper.selectById(req.getRequirementId());
    if (requirement == null) throw new ApiException("需求不存在");
    
    // 2. 校验剩余数量
    BigDecimal remaining = calculateRemaining(requirement);
    if (remaining.compareTo(req.getQuantity()) < 0) {
        throw new ApiException("成交数量超过剩余数量");
    }
    
    // 3. 创建成交记录
    Deal deal = buildDeal(req, requirement);
    dealMapper.insert(deal);
    
    // 4. 更新需求状态
    updateRequirementStatus(requirement, req.getQuantity());
    
    return deal.getId();
}
```

### 2.2 查询优化
```java
// ✅ 避免 N+1 查询，使用批量查询
public List<SupplyDTO> listWithCompany(List<Long> supplyIds) {
    List<Supply> supplies = supplyMapper.selectByIds(supplyIds);
    
    // 批量查询关联公司
    Set<Long> companyIds = supplies.stream()
        .map(Supply::getCompanyId)
        .collect(Collectors.toSet());
    Map<Long, Company> companyMap = companyMapper.selectByIds(companyIds)
        .stream()
        .collect(Collectors.toMap(Company::getId, Function.identity()));
    
    // 组装 DTO
    return supplies.stream()
        .map(s -> toDTO(s, companyMap.get(s.getCompanyId())))
        .toList();
}
```

## 3. 数据访问层规范

### 3.1 MyBatis Mapper
```java
// ✅ 接口方法命名规范
public interface SupplyMapper {
    Supply selectById(Long id);
    List<Supply> selectByCompanyId(Long companyId);
    List<Supply> selectByCondition(SupplyQueryCondition condition);
    int insert(Supply supply);
    int updateById(Supply supply);
    int deleteById(Long id); // 逻辑删除
}
```

### 3.2 XML 动态查询
```xml
<!-- ✅ 使用 <where> 和 <if> 构建动态条件 -->
<select id="selectByCondition" resultType="Supply">
    SELECT * FROM bus_supply
    <where>
        del_flag = 0
        <if test="companyId != null">
            AND company_id = #{companyId}
        </if>
        <if test="categoryName != null and categoryName != ''">
            AND category_name LIKE CONCAT('%', #{categoryName}, '%')
        </if>
        <if test="status != null">
            AND status = #{status}
        </if>
    </where>
    ORDER BY create_time DESC
</select>
```

## 4. 安全规范

### 4.1 SQL 注入防护
```java
// ✅ 使用参数化查询
@Select("SELECT * FROM bus_company WHERE company_name = #{name}")
Company selectByName(@Param("name") String name);

// ❌ 禁止字符串拼接 SQL
// "SELECT * FROM bus_company WHERE company_name = '" + name + "'"
```

### 4.2 敏感数据脱敏
```java
// ✅ 返回前端时脱敏
public String maskPhone(String phone) {
    if (phone == null || phone.length() < 7) return phone;
    return phone.substring(0, 3) + "****" + phone.substring(7);
}

public String maskIdCard(String idCard) {
    if (idCard == null || idCard.length() < 14) return idCard;
    return idCard.substring(0, 6) + "********" + idCard.substring(14);
}
```

---

# 第九部分：UI/UX 高级设计模式

> 基于 Smithery `ui-ux-pro-max` 技能，引入 2025 年前沿设计趋势。

## 1. Bento Grid 布局（仪表盘首选）

```html
<!-- ✅ 现代 Bento Grid 布局 -->
<div class="grid grid-cols-4 gap-4 auto-rows-[120px]">
  <!-- 大卡片：跨 2 列 2 行 -->
  <div class="col-span-2 row-span-2 bg-white rounded-2xl p-6 border border-gray-100">
    <h3 class="text-lg font-bold">核心指标</h3>
    <!-- 内容 -->
  </div>
  
  <!-- 小卡片 -->
  <div class="bg-white rounded-2xl p-4 border border-gray-100">
    <span class="text-xs text-gray-500">今日成交</span>
    <p class="text-2xl font-bold">128</p>
  </div>
  
  <!-- 更多卡片... -->
</div>
```

## 2. 毛玻璃效果（Glassmorphism）

```html
<!-- ✅ 毛玻璃弹窗/浮层 -->
<div class="fixed inset-0 bg-slate-900/40 backdrop-blur-md">
  <div class="bg-white/80 backdrop-blur-xl rounded-3xl shadow-2xl border border-white/20">
    <!-- 内容 -->
  </div>
</div>
```

## 3. 微交互动效

```html
<!-- ✅ 卡片悬浮效果 -->
<div class="group bg-white rounded-2xl p-6 border border-gray-100 
            transition-all duration-300 ease-out
            hover:shadow-lg hover:border-emerald-200 hover:-translate-y-1">
  <div class="transition-transform duration-300 group-hover:scale-105">
    <!-- 图标或图片 -->
  </div>
</div>

<!-- ✅ 按钮点击反馈 -->
<button class="bg-emerald-600 text-white px-6 py-2.5 rounded-xl font-bold
               transition-all duration-150 ease-out
               hover:bg-emerald-700 hover:shadow-md
               active:scale-95 active:shadow-sm">
  确认提交
</button>
```

## 4. 空状态设计

```html
<!-- ✅ 情感化空状态 -->
<div class="flex flex-col items-center justify-center py-16 text-center">
  <div class="w-24 h-24 bg-gray-50 rounded-full flex items-center justify-center mb-6">
    <Package class="w-12 h-12 text-gray-300" />
  </div>
  <h3 class="text-lg font-bold text-gray-900 mb-2">暂无供应信息</h3>
  <p class="text-sm text-gray-500 mb-6 max-w-xs">
    您还没有发布任何供应，点击下方按钮开始发布您的第一条供应信息
  </p>
  <button class="bg-emerald-600 hover:bg-emerald-700 text-white px-6 py-2.5 rounded-xl font-bold transition-all">
    立即发布
  </button>
</div>
```
